# C++におけるbit全探索の基本

## 1. bit全探索の基本的アイディア
- bit全探索とは、集合や選択肢の「有る/無い」を **ビット列**で表現し、全ての組み合わせを列挙。
- 部分集合の数は `2^N` 通りで、各要素を「選ぶ=1 / 選ばない=0」として表す。
- 例: N=3 の集合 `{A, B, C}` の部分集合


| ビット列 (2進数) | 10進数 | 部分集合 |
|------------------|--------|-----------|
| 000              | 0      | {}        |
| 001              | 1      | {C}       |
| 010              | 2      | {B}       |
| 011              | 3      | {B, C}    |
| 100              | 4      | {A}       |
| 101              | 5      | {A, C}    |
| 110              | 6      | {A, B}    |
| 111              | 7      | {A, B, C} |

---


## 2. C++での基本実装

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N = 3;
    vector<char> elems = {'A', 'B', 'C'};

    for (int bit = 0; bit < (1 << N); bit++) {
        cout << "{ ";
        for (int i = 0; i < N; i++) {
            if (bit & (1 << i)) {
                cout << elems[i] << " ";
            }
        }
        cout << "}" << endl;
    }
}
```
---

## 3. 実行結果

```
{ }
{ A }
{ B }
{ A B }
{ C }
{ A C }
{ B C }
{ A B C }
```

---

## 4. bit演算の解説
- `(1 << N)` は 2^N を意味する。
- `(bit & (1 << i))` は i番目のビットが立っているかを判定する。
- 例: bit = 5 (101) の場合
  - `(bit & (1 << 0))` → 1 （0番目の要素を選ぶ）
  - `(bit & (1 << 1))` → 0 （1番目の要素は選ばない）
  - `(bit & (1 << 2))` → 4 （2番目の要素を選ぶ）

---

<!-- ## 5. 部分和問題への応用

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N = 4, W = 9;
    vector<int> A = {1, 3, 5, 7};

    bool exist = false;
    //bitを0から2^Nまでインクリメントして部分集合を列挙する
    for (int bit = 0; bit < (1 << N); bit++) {
        int sum = 0;
        for (int i = 0; i < N; i++) {
            if (bit & (1 << i)) sum += A[i];//i番目のビットが立っているとき和を取る。
        }
        if (sum == W) exist = true;
    }

    cout << (exist ? "Yes" : "No") << endl;
}
```

### 実行結果

Yes

--- -->

## 5. 計算量
- 外側ループ: `2^N` 回
- 内側ループ: `N` 回
- 全体の計算量: `O(N * 2^N)`
- `N ≈ 20` までが現実的

---

## 6. よく使うテクニック
- 部分集合の要素数を数える: `__builtin_popcount(bit)`
- 部分集合の合計や積を計算する
- set や map で部分集合ごとの値を管理して重複を排除する

---

